package protocol

import (
	"bytes"
	"testing"
)

func TestMySQLMessageBuild(t *testing.T) {
	type TestCase struct {
		input MySQLMessage
		except []byte
	}
	testCase := []TestCase{
		{
			input: MySQLMessage{78, 0, []byte{
				0x0a, 0x35, 0x2e, 0x37, 0x2e, 0x32, 0x36, 0x2d,
				0x6c, 0x6f, 0x67, 0x00, 0x04, 0x00, 0x00, 0x00,
				0x0c, 0x76, 0x52, 0x48, 0x5c, 0x0a, 0x01, 0x58,
				0x00, 0xff, 0xf7, 0xc0, 0x02, 0x00, 0xff, 0x81,
				0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x75, 0x0b, 0x3b, 0x01, 0x5c,
				0x17, 0x51, 0x39, 0x2a, 0x27, 0x61, 0x29, 0x00,
				0x6d, 0x79, 0x73, 0x71, 0x6c, 0x5f, 0x6e, 0x61,
				0x74, 0x69, 0x76, 0x65, 0x5f, 0x70, 0x61, 0x73,
				0x73, 0x77, 0x6f, 0x72, 0x64, 0x00,
			}},
			except: []byte{
				0x4e, 0x00, 0x00, 0x00, 0x0a, 0x35, 0x2e, 0x37,
				0x2e, 0x32, 0x36, 0x2d, 0x6c, 0x6f, 0x67, 0x00,
				0x04, 0x00, 0x00, 0x00, 0x0c, 0x76, 0x52, 0x48,
				0x5c, 0x0a, 0x01, 0x58, 0x00, 0xff, 0xf7, 0xc0,
				0x02, 0x00, 0xff, 0x81, 0x15, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75,
				0x0b, 0x3b, 0x01, 0x5c, 0x17, 0x51, 0x39, 0x2a,
				0x27, 0x61, 0x29, 0x00, 0x6d, 0x79, 0x73, 0x71,
				0x6c, 0x5f, 0x6e, 0x61, 0x74, 0x69, 0x76, 0x65,
				0x5f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72,
				0x64, 0x00,
			},
		},
	}

	for _, v := range testCase {
		actual := v.input.Build()
		except := v.except
		if !bytes.Equal(actual, except) {
			t.Errorf("input: \n[%+v] \n actual: \n[%+v] \n except: \n[%+v] \n", v.input, actual, except)
		}
	}
}

func TestMySQLMessageResolve(t *testing.T) {
	actual := new(MySQLMessage)
	bs := []byte{
		0x4e, 0x00, 0x00, 0x00, 0x0a, 0x35, 0x2e, 0x37,
		0x2e, 0x32, 0x36, 0x2d, 0x6c, 0x6f, 0x67, 0x00,
		0x04, 0x00, 0x00, 0x00, 0x0c, 0x76, 0x52, 0x48,
		0x5c, 0x0a, 0x01, 0x58, 0x00, 0xff, 0xf7, 0xc0,
		0x02, 0x00, 0xff, 0x81, 0x15, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75,
		0x0b, 0x3b, 0x01, 0x5c, 0x17, 0x51, 0x39, 0x2a,
		0x27, 0x61, 0x29, 0x00, 0x6d, 0x79, 0x73, 0x71,
		0x6c, 0x5f, 0x6e, 0x61, 0x74, 0x69, 0x76, 0x65,
		0x5f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72,
		0x64, 0x00,
	}
	actual.Resolve(bs)

	except := new(MySQLMessage)
	except.PayloadLength = 78
	except.SequenceId = 0
	except.Payload = []byte{
		0x0a, 0x35, 0x2e, 0x37, 0x2e, 0x32, 0x36, 0x2d,
		0x6c, 0x6f, 0x67, 0x00, 0x04, 0x00, 0x00, 0x00,
		0x0c, 0x76, 0x52, 0x48, 0x5c, 0x0a, 0x01, 0x58,
		0x00, 0xff, 0xf7, 0xc0, 0x02, 0x00, 0xff, 0x81,
		0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x75, 0x0b, 0x3b, 0x01, 0x5c,
		0x17, 0x51, 0x39, 0x2a, 0x27, 0x61, 0x29, 0x00,
		0x6d, 0x79, 0x73, 0x71, 0x6c, 0x5f, 0x6e, 0x61,
		0x74, 0x69, 0x76, 0x65, 0x5f, 0x70, 0x61, 0x73,
		0x73, 0x77, 0x6f, 0x72, 0x64, 0x00,
	}

	if actual.PayloadLength != except.PayloadLength {
		t.Errorf("test PayloadLength \n actual: \n[%+v] \n except: \n[%+v] \n", actual.PayloadLength, except.PayloadLength)
	}
	if actual.SequenceId != except.SequenceId {
		t.Errorf("test SequenceId \n actual: \n[%+v] \n except: \n[%+v] \n", actual.SequenceId, except.SequenceId)
	}
	if !bytes.Equal(actual.Payload, except.Payload) {
		t.Errorf("test Payload \n actual: \n[%+v] \n except: \n[%+v] \n", actual.Payload, except.Payload)
	}
}
